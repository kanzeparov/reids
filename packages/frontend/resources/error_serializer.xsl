<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet
    version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:output method="text" encoding="Windows-1252"/>
<xsl:template name="TypeIn">
    <xsl:param name="type"/>
    <xsl:param name="optional" select="'false'"/>
    <xsl:param name="value"/>
    <xsl:param name="function_name" select='none'/>
    <xsl:param name="arg" select='none'/>
    <xsl:param name="return" select='none'/>
    <xsl:choose>
      <xsl:when test="$type='moment.Moment'"><xsl:choose>
        <xsl:when test="$optional='true'"><xsl:value-of select="$value"/> ? moment(<xsl:value-of select="$value"/>).utc() : undefined</xsl:when>
        <xsl:otherwise>moment(<xsl:value-of select="$value"/>).utc()</xsl:otherwise></xsl:choose></xsl:when>
      <xsl:when test="$type='BigNumber'"><xsl:choose>
        <xsl:when test="$optional='true'"><xsl:value-of select="$value"/> ? new BigNumber(<xsl:value-of select="$value"/>) : undefined</xsl:when>
        <xsl:otherwise>new BigNumber(<xsl:value-of select="$value"/>)</xsl:otherwise></xsl:choose></xsl:when>
      <xsl:when test="$type='function'"><xsl:choose>
    <xsl:when test="./@side='back'"><xsl:call-template name="TypeIn">
      <xsl:with-param name="type" select="$return"/>
      <xsl:with-param name="value"><xsl:value-of select="$value"/></xsl:with-param></xsl:call-template></xsl:when>
    <xsl:otherwise>async function(instance) {
      const result = await ErrorFunctions.<xsl:value-of select="$function_name"/>(<xsl:for-each select="$arg"><xsl:if test="position() != 1">, </xsl:if><xsl:choose>
      <xsl:when test="$type='parameter'">data.<xsl:value-of select="./@value"/>.value</xsl:when>
    </xsl:choose></xsl:for-each>)
      return <xsl:call-template name="TypeIn">
      <xsl:with-param name="type" select="$return"/>
      <xsl:with-param name="value">result</xsl:with-param></xsl:call-template>
      </xsl:otherwise></xsl:choose></xsl:when>
      <xsl:otherwise><xsl:value-of select="$value"/></xsl:otherwise></xsl:choose>
</xsl:template>

    <xsl:template match="/" >
// Autogenerated file
import * as moment from 'moment'
import BigNumber from 'bignumber.js'
import { IError,
         ErrorType, <xsl:for-each select="/errors/error">IError<xsl:value-of select="./@name"/><xsl:if test="position() &lt; last()">,
         </xsl:if></xsl:for-each> } from '@onder/interfaces'

export default class ErrorSerializer {
  private constructor () {
  }
<xsl:for-each select="/errors/error">
  static async deserialize<xsl:value-of select="./@name"/>Error (errorObj: string): Promise&lt;IError<xsl:value-of select="./@name"/>> {
    try {
      <xsl:if test="count(./*) != 0">let data = JSON.parse(errorObj)
      </xsl:if>return Promise.resolve({ type: ErrorType.<xsl:value-of select="./@name"/><xsl:for-each select="./parameter">,
        <xsl:value-of select="./@name"/>: <xsl:call-template name="TypeIn">
      <xsl:with-param name="type" select="./@type"/>
    <xsl:with-param name="optional" select="./@optional"/>
    <xsl:with-param name="value">data.<xsl:value-of select="./@name"/>.value</xsl:with-param>
    <xsl:with-param name="function_name" select='./@function_name'/>
    <xsl:with-param name="arg" select='./arg'/>
    <xsl:with-param name="return" select='./@return'/></xsl:call-template></xsl:for-each> } as IError<xsl:value-of select="./@name"/>)
    } catch (e) {
      return Promise.reject(e)
    }
  }

  static async normalize<xsl:value-of select="./@name"/>Error (data: any): Promise&lt;IError<xsl:value-of select="./@name"/>> {
    try {
      return Promise.resolve({ type: ErrorType.<xsl:value-of select="./@name"/><xsl:for-each select="./parameter">,
        <xsl:value-of select="./@name"/>: <xsl:call-template name="TypeIn">
      <xsl:with-param name="type" select="./@type"/>
    <xsl:with-param name="optional" select="./@optional"/>
    <xsl:with-param name="value">data.<xsl:value-of select="./@name"/>.value</xsl:with-param>
    <xsl:with-param name="function_name" select='./@function_name'/>
    <xsl:with-param name="arg" select='./arg'/>
    <xsl:with-param name="return" select='./@return'/></xsl:call-template></xsl:for-each> } as IError<xsl:value-of select="./@name"/>)
    } catch (e) {
      return Promise.reject(e)
    }
  }
</xsl:for-each>
  static deserializeError (str: string): Promise&lt;IError> {
    let tmpObject = undefined
    try {
      tmpObject = JSON.parse(str)
    } catch (e) {
      return Promise.reject(e)
    }
    if (!tmpObject) {
      return Promise.reject('undefined object')
    }
    if (!('type' in tmpObject)) {
      return Promise.reject('Required field type doesnt exist')
    }
    switch (tmpObject.type) {
      <xsl:for-each select="/errors/error">case ErrorType.<xsl:value-of select="./@name"/>:
        return ErrorSerializer.deserialize<xsl:value-of select="./@name"/>Error(str)
      </xsl:for-each>default:
        return Promise.reject(`Unknown error type ${tmpObject.type}`)
    }
  }

  static normalizeError (obj: any): Promise&lt;IError> {
    if (!('type' in obj)) {
      return Promise.reject(`Unknown error type`)
    }
    switch (obj.type) {
      <xsl:for-each select="/errors/error">case ErrorType.<xsl:value-of select="./@name"/>:
        return ErrorSerializer.normalize<xsl:value-of select="./@name"/>Error(obj)
      </xsl:for-each>default:
        return Promise.reject(`Unknown error type ${obj.type}`)
    }
  }
}
</xsl:template>
</xsl:stylesheet>
