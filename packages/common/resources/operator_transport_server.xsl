<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet
    version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:output method="text" encoding="Windows-1252"/>

<xsl:template name="TypeIn">
    <xsl:param name="type"/>
    <xsl:param name="value"/>
    <xsl:choose>
        <xsl:when test="$type='BigNumber'">new BigNumber(<xsl:value-of select="$value"/>)</xsl:when>
        <xsl:when test="$type='Moment'">moment(<xsl:value-of select="$value"/>).utc()</xsl:when>
        <xsl:when test="starts-with($type, 'Array&lt;')"><xsl:value-of select="$value"/>.map((item: <xsl:value-of select="substring($type, 7, string-length($type) - 7)"/>) => {
        return <xsl:call-template name="TypeIn">
        <xsl:with-param name="type" select="substring($type, 7, string-length($type) - 7)"/>
        <xsl:with-param name="value">item</xsl:with-param>
      </xsl:call-template>
      })</xsl:when>
        <xsl:otherwise><xsl:value-of select="$value"/></xsl:otherwise>
    </xsl:choose>
</xsl:template>
    <xsl:template match="/" >
// Autogenerated file
import BigNumber from 'bignumber.js'
import moment from 'moment'
import {<xsl:for-each select="/operator/events/event[not(@customrecerver) or @customrecerver!='true']">
         I<xsl:value-of select="./@name"/>Event,</xsl:for-each>
         IOperatorTransportCallback
} from '@onder/interfaces'
import io from 'socket.io'
import * as http from 'http'
import AddressService from '../AddressService'
import { initOperatorTransportServerSocket, getOperatorTransportServerSocketClient } from './OperatorTransportHelper'
import Logger from '@machinomy/logger'
const log = new Logger('onder-common-operatorserver')

export default class OperatorTransportServer {
  private readonly callback: IOperatorTransportCallback
  private readonly server: http.Server
  private readonly ioapp: io.Server
  private readonly port: number
  private readonly addressService: AddressService

  constructor (port: number, addressService: AddressService, callback: IOperatorTransportCallback) {
    this.callback = callback
    this.server = http.createServer()
    this.ioapp = io(this.server, {
      path: '/api/v1'
    })
    this.port = port
    this.addressService = addressService
  }
  async start (): Promise&lt;Object> {
    return this.server.listen(this.port, undefined, undefined, () => {
      this.addressService.announce().operatorTransport('', this.port)
      log.info(`Operator server start on ${this.port}`)
      this.ioapp.of('<xsl:value-of select="/operator/@endpoint"/>').on('connection', (socket: any) => {
        initOperatorTransportServerSocket(this, this.ioapp, socket, this.callback)<xsl:for-each select="/operator/events/event[not(@customrecerver) or @customrecerver!='true']">
        socket.on('<xsl:value-of select="./@name"/>Event', (data: any) => {
          this.callback.on<xsl:value-of select="./@name"/>({ <xsl:for-each select="./param"><xsl:value-of select="./@name"/>: <xsl:choose>
            <xsl:when test="not(not(./@customrecerver))"><xsl:value-of select="./@customrecerver"/>(this, this.ioapp, socket, this.callback, data)</xsl:when>
            <xsl:when test="./@optional='true'">data.<xsl:value-of select="./@name"/> ? <xsl:call-template name="TypeIn">
            <xsl:with-param name="type" select="./@type"/>
            <xsl:with-param name="value">data.<xsl:value-of select="./@name"/></xsl:with-param>
          </xsl:call-template> : undefined</xsl:when>
            <xsl:otherwise><xsl:call-template name="TypeIn">
            <xsl:with-param name="type" select="./@type"/>
            <xsl:with-param name="value">data.<xsl:value-of select="./@name"/></xsl:with-param>
          </xsl:call-template></xsl:otherwise></xsl:choose><xsl:if test="position() != last()">,
            </xsl:if></xsl:for-each> } as I<xsl:value-of select="./@name"/>Event).catch((reason) => {
              log.error('Error when call this.callback.on<xsl:value-of select="./@name"/>', reason)
            })
        })</xsl:for-each>
      })
    })
  }
}
</xsl:template>
</xsl:stylesheet>
