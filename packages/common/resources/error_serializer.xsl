<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet
    version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:output method="text" encoding="Windows-1252"/>

    <xsl:template match="/" >
// Autogenerated file
import moment from 'moment'
import BigNumber from 'bignumber.js'
import { IError,
         ErrorType, <xsl:for-each select="/errors/error">IError<xsl:value-of select="./@name"/><xsl:if test="position() &lt; last()">,
         </xsl:if></xsl:for-each> } from '@onder/interfaces'

export default class ErrorSerializer {
  private constructor () {
  }
<xsl:for-each select="/errors/error">
  static serialize<xsl:value-of select="./@name"/>Error (errorObj: IError<xsl:value-of select="./@name"/>): string {
    return JSON.stringify({ type: ErrorType.<xsl:value-of select="./@name"/><xsl:for-each select="./parameter">,
      <xsl:value-of select="./@name"/>: { type: '<xsl:value-of select="./@type"/>', value: <xsl:choose>
      <xsl:when test="./@type='moment.Moment'">errorObj.<xsl:value-of select="./@name"/>.valueOf()</xsl:when>
      <xsl:when test="./@type='function'">errorObj.<xsl:value-of select="./@name"/></xsl:when>
      <xsl:otherwise>errorObj.<xsl:value-of select="./@name"/></xsl:otherwise></xsl:choose> }</xsl:for-each> })
  }

  static async deserialize<xsl:value-of select="./@name"/>Error (errorObj: string): Promise&lt;IError<xsl:value-of select="./@name"/>> {
    try {
      <xsl:if test="count(./*) != 0">let data = JSON.parse(errorObj)
      </xsl:if>return Promise.resolve({ type: ErrorType.<xsl:value-of select="./@name"/><xsl:for-each select="./parameter">,
        <xsl:value-of select="./@name"/>: <xsl:choose>
      <xsl:when test="./@type='moment.Moment'"><xsl:choose>
        <xsl:when test="./@optional='true'">data.<xsl:value-of select="./@name"/>.value ? moment(data.<xsl:value-of select="./@name"/>.value).utc() : undefined</xsl:when>
        <xsl:otherwise>moment(data.<xsl:value-of select="./@name"/>.value).utc()</xsl:otherwise></xsl:choose></xsl:when>
      <xsl:when test="./@type='BigNumber'"><xsl:choose>
        <xsl:when test="./@optional='true'">data.<xsl:value-of select="./@name"/>.value ? new BigNumber(data.<xsl:value-of select="./@name"/>.value) : undefined</xsl:when>
        <xsl:otherwise>new BigNumber(data.<xsl:value-of select="./@name"/>.value)</xsl:otherwise></xsl:choose></xsl:when>
      <xsl:when test="./@type='function'"><xsl:choose>
    <xsl:when test="./@side='back'">await ErrorFunctions.<xsl:value-of select="./@function_name"/>(<xsl:for-each select="./arg"><xsl:if test="position() != 1">, </xsl:if><xsl:choose>
      <xsl:when test="./@type='parameter'">data.<xsl:value-of select="./@value"/>.value</xsl:when>
    </xsl:choose></xsl:for-each>)</xsl:when>
    <xsl:otherwise>undefined</xsl:otherwise></xsl:choose></xsl:when>
      <xsl:otherwise>data.<xsl:value-of select="./@name"/>.value</xsl:otherwise></xsl:choose></xsl:for-each> } as IError<xsl:value-of select="./@name"/>)
    } catch (e) {
      return Promise.reject(e)
    }
  }

  static async normalize<xsl:value-of select="./@name"/>Error (data: any): Promise&lt;IError<xsl:value-of select="./@name"/>> {
    try {
      return Promise.resolve({ type: ErrorType.<xsl:value-of select="./@name"/><xsl:for-each select="./parameter">,
        <xsl:value-of select="./@name"/>: <xsl:choose>
      <xsl:when test="./@type='moment.Moment'"><xsl:choose>
        <xsl:when test="./@optional='true'">data.<xsl:value-of select="./@name"/>.value ? moment(data.<xsl:value-of select="./@name"/>.value).utc() : undefined</xsl:when>
        <xsl:otherwise>moment(data.<xsl:value-of select="./@name"/>.value).utc()</xsl:otherwise></xsl:choose></xsl:when>
      <xsl:when test="./@type='BigNumber'"><xsl:choose>
        <xsl:when test="./@optional='true'">data.<xsl:value-of select="./@name"/>.value ? new BigNumber(data.<xsl:value-of select="./@name"/>.value) : undefined</xsl:when>
        <xsl:otherwise>new BigNumber(data.<xsl:value-of select="./@name"/>.value)</xsl:otherwise></xsl:choose></xsl:when>
      <xsl:when test="./@type='function'"><xsl:choose>
    <xsl:when test="./@side='back'">await ErrorFunctions.<xsl:value-of select="./@function_name"/>(<xsl:for-each select="./arg"><xsl:if test="position() != 1">, </xsl:if><xsl:choose>
      <xsl:when test="./@type='parameter'">data.<xsl:value-of select="./@value"/>.value</xsl:when>
    </xsl:choose></xsl:for-each>)</xsl:when>
    <xsl:otherwise>undefined</xsl:otherwise></xsl:choose></xsl:when>
      <xsl:otherwise>data.<xsl:value-of select="./@name"/>.value</xsl:otherwise></xsl:choose></xsl:for-each> } as IError<xsl:value-of select="./@name"/>)
    } catch (e) {
      return Promise.reject(e)
    }
  }
</xsl:for-each>
  static serializeError (errorObj: IError): string {
    switch (errorObj.type) {
      <xsl:for-each select="/errors/error">case ErrorType.<xsl:value-of select="./@name"/>:
        return ErrorSerializer.serialize<xsl:value-of select="./@name"/>Error(errorObj)
      </xsl:for-each>default:
        return ''
    }
  }

  static deserializeError (type: ErrorType, str: string): Promise&lt;IError> {
    switch (type) {
      <xsl:for-each select="/errors/error">case ErrorType.<xsl:value-of select="./@name"/>:
        return ErrorSerializer.deserialize<xsl:value-of select="./@name"/>Error(str)
      </xsl:for-each>default:
        return Promise.reject(`Unknown error type ${type}`)
    }
  }

  static normalizeError (obj: any): Promise&lt;IError> {
    if (!('type' in obj)) {
      return Promise.reject(`Unknown error type`)
    }
    switch (obj.type) {
      <xsl:for-each select="/errors/error">case ErrorType.<xsl:value-of select="./@name"/>:
        return ErrorSerializer.normalize<xsl:value-of select="./@name"/>Error(obj)
      </xsl:for-each>default:
        return Promise.reject(`Unknown error type ${obj.type}`)
    }
  }
}
</xsl:template>
</xsl:stylesheet>
