<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet
    version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:output method="text" encoding="Windows-1252"/>

<xsl:template name="TypeOut">
    <xsl:param name="type"/>
    <xsl:param name="value"/>
    <xsl:choose>
        <xsl:when test="$type='BigNumber'"><xsl:value-of select="$value"/>.toString()</xsl:when>
        <xsl:when test="$type='Moment'"><xsl:value-of select="$value"/>.valueOf()</xsl:when>
        <xsl:when test="starts-with($type, 'Array&lt;')"><xsl:value-of select="$value"/>.map((item: <xsl:value-of select="substring($type, 7, string-length($type) - 7)"/>) => {
        return <xsl:call-template name="TypeOut">
        <xsl:with-param name="type" select="substring($type, 7, string-length($type) - 7)"/>
        <xsl:with-param name="value">item</xsl:with-param>
      </xsl:call-template>
      })</xsl:when>
        <xsl:otherwise><xsl:value-of select="$value"/></xsl:otherwise>
    </xsl:choose>
</xsl:template>
    <xsl:template match="/" >
// Autogenerated file
import { BigNumber } from 'bignumber.js'
import { Moment } from 'moment'
import {<xsl:for-each select="/operator/interfaces/interface">
  <xsl:value-of select="./@name"/>,</xsl:for-each>
  ErrorType,
  IOperatorClient } from '@onder/interfaces'
import AddressService from '../AddressService'
import * as io from 'socket.io-client'
import Logger from '@machinomy/logger'
const log = new Logger('onder-common-operatortransportclient')

class OperatorTransportClient implements IOperatorClient {
  private socket?: SocketIOClient.Socket
  private readonly addressService: AddressService
  private client: IClient<xsl:for-each select="/operator/events/event[@reconnectevent='true']">
  private <xsl:value-of select="./@name"/>Sended: boolean = false</xsl:for-each>

  constructor (account: string, addressService: AddressService) {
    this.client = {
      account: account
    }
    this.addressService = addressService
    this.sendConnect(this.client).catch((reason: any) => {
      log.error("Can't connect to server initialy", reason)
    })
  }
  private async connect (): Promise&lt;SocketIOClient.Socket> {
    if (this.socket) {
      return Promise.resolve(this.socket)
    }
    let address = await this.addressService.resolve().operatorTransport()
    const socket = io.connect(address + '/socketoperator', { path: '/api/v1' })
    if (socket) {
      this.socket = socket
      socket.on('connect', () => {
        <xsl:for-each select="/operator/events/event[@reconnectevent='true']">this.sendConnect().then(() => {
          this.<xsl:value-of select="./@name"/>Sended = true
        }).catch((reason) => {
          this.<xsl:value-of select="./@name"/>Sended = false
          log.error("Can't send connection event", reason)
        })</xsl:for-each>
      })
      socket.on('connecting', () => {<xsl:for-each select="/operator/events/event[@reconnectevent='true']">
        this.<xsl:value-of select="./@name"/>Sended = false</xsl:for-each>
      })
      socket.on('reconnecting', () => {<xsl:for-each select="/operator/events/event[@reconnectevent='true']">
        this.<xsl:value-of select="./@name"/>Sended = false</xsl:for-each>
      })
      socket.on('connect_failed', (reason: any) => {
        log.error("Can't connect to operator server", reason)
      })
      socket.on('reconnect_failed', (reason: any) => {
        log.error("Can't connect to operator server", reason)
      })
      socket.on('error', (reason: any) => {
        log.error('Error recerved from operator server', reason)
      })
      return Promise.resolve(socket)
    }
    return Promise.reject("Can't connect to operator server")
  }<xsl:for-each select="/operator/events/event[not(@cansend) or @cansend!='false']">
  send<xsl:value-of select="./@name"/> (<xsl:for-each select="./param[not(@customrecerver)]"><xsl:value-of select="./@name"/><xsl:if test="./@optional='true'">?</xsl:if>: <xsl:value-of select="./@type"/><xsl:if test="./@default"> = <xsl:value-of select="./@default"/></xsl:if><xsl:if test="position() != last()">, </xsl:if></xsl:for-each>): Promise&lt;void> {
    return this.connect().then((socket: SocketIOClient.Socket) => {<xsl:variable name="origin" select="current()"/>
      <xsl:for-each select="/operator/events/event[@reconnectevent='true' and @name!=$origin/@name]">
      if (!this.<xsl:value-of select="./@name"/>Sended) {
        return this.send<xsl:value-of select="./@name"/>(<xsl:for-each select="./param[not(@customrecerver) and not(@default)]"><xsl:value-of select="./@name"/><xsl:if test="position() != last()">, </xsl:if></xsl:for-each>).then(() => {
          return this.send<xsl:value-of select="$origin/@name"/>(<xsl:for-each select="$origin/param[not(@customrecerver)]"><xsl:value-of select="./@name"/><xsl:if test="position() != last()">, </xsl:if></xsl:for-each>)
        })
      }</xsl:for-each>
      if (socket.emit('<xsl:value-of select="./@name"/>Event', {
        <xsl:for-each select="./param[not(@customrecerver)]"><xsl:value-of select="./@name"/>: <xsl:choose>
          <xsl:when test="./@optional='true'"><xsl:value-of select="./@name"/> ? <xsl:call-template name="TypeOut">
          <xsl:with-param name="type" select="./@type"/>
          <xsl:with-param name="value"><xsl:value-of select="./@name"/></xsl:with-param>
        </xsl:call-template> : undefined</xsl:when>
          <xsl:otherwise><xsl:call-template name="TypeOut">
          <xsl:with-param name="type" select="./@type"/>
          <xsl:with-param name="value"><xsl:value-of select="./@name"/></xsl:with-param>
        </xsl:call-template></xsl:otherwise></xsl:choose><xsl:if test="position() != last()">, </xsl:if></xsl:for-each>
      })) {<xsl:if test="./@reconnectevent='true'">
        this.<xsl:value-of select="./@name"/>Sended = true</xsl:if>
        return Promise.resolve()
      } else {<xsl:if test="./@reconnectevent='true'">
        this.<xsl:value-of select="./@name"/>Sended = false</xsl:if>
        return Promise.reject('send<xsl:value-of select="./@name"/> emit return false')
      }
    })<xsl:if test="./@reconnectevent='true'">.catch((reason) => {
      this.<xsl:value-of select="./@name"/>Sended = false
      log.error('Error when call send<xsl:value-of select="./@name"/>', reason)
      return Promise.reject(reason)
    })</xsl:if>
  }</xsl:for-each>
}

export default class OperatorTransportClientFacade implements IOperatorClient {
  private impl?: IOperatorClient
  private account: string
  constructor (account: string, allowSendStatistic: boolean, addressService: AddressService) {
    this.account = account
    if (allowSendStatistic) {
      this.impl = new OperatorTransportClient(this.account, addressService)
    } else {
      this.impl = undefined
    }
  }<xsl:for-each select="/operator/events/event[not(@cansend) or @cansend!='false']">
  send<xsl:value-of select="./@name"/> (<xsl:for-each select="./param[not(@customrecerver)]"><xsl:value-of select="./@name"/><xsl:if test="./@optional='true'">?</xsl:if>: <xsl:value-of select="./@type"/><xsl:if test="position() != last()">, </xsl:if></xsl:for-each>): Promise&lt;void> {
    if (this.impl) {
      return this.impl.send<xsl:value-of select="./@name"/>(<xsl:for-each select="./param[not(@customrecerver)]"><xsl:value-of select="./@name"/><xsl:if test="position() != last()">, </xsl:if></xsl:for-each>)
    }
    return Promise.resolve()
  }</xsl:for-each>
}
</xsl:template>
</xsl:stylesheet>
